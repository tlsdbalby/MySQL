## 二、MySQL引擎

### 1、MyISAM

早期引擎，数据内容与索引结构分开存放为两个文件。

### 2、InnoDB

目前的主流MySQL引擎，数据与索引存放与一个文件当中。



## 三、索引分类

### 1、主键索引 （primary key）

在MySQL数据库中，数据表的主键列会被**默认**创建索引，称为**主键索引**，因此在表查询过程中，使用主键查询的性能非常好。

### 2、普通索引

根据普通列创建的索引，通过手动创建。需要注意的是，创建普通索引需要生成新的索引结构，因此在数据量较大时，会是一个耗时操作；同时索引的维护也是一个耗时操作，所以在创建普通索引时一定要慎重，只有某列确实是高频查询条件时，才考虑依据此列构造索引。

命令格式：

```mysql
create inde idx_col_name(索引名) on table[col_name]（索引所在的表及列名）
```

### 3、唯一索引

在数据表中，某些列具有**特殊属性**，例如值是不重复的（类似于主键），这样的列可以构建唯一索引，其**性能要优于普通索引**。

```mysql
create unique index idx_col_name on table[col_name]
```

### 4、联合索引/组合索引

表中的多个字段创建一个共同的索引，注意这个索引与列的关系是**1：n**，建议一个联合索引不要超过5个列。联合索引的使用方式和其他索引不太一样，因为其对应着多个列，所以在索引命中上要遵循**最左前缀法则**（第五节详述）。

```mysql
create index idx_col_name1_name2... on table[col_name1, col_name2]
```

### 5、全文索引

全文索引是针对文本内容查询的一种索引结构，应用场景更多的是搜索引擎或大数据引擎中，在MySQL环境不太会出现（虽然MyISAM引擎支持全文索引，但实际开发场景中不会用它），目前使用较多的全文索引软件包括**ElasticSearch**、Solr。

### 总结

对于MySQL数据表来说，一定包含：至少一个的主键索引，可以包含：多个普通索引、联合索引。

在查询任务中，能走索引尽量走索引，没有索引可以构建索引，但大量的索引会导致数据表的维护成本升高，因此若是索引过多，则需要考虑是表结构设计有问题或是无法适应当前业务场景的需求。



## 四、索引结构

使用索引结构组织数据可提高数据的查询性能，因此有索引和没索引，差距很大，但同时需要注意的是，使用不同的数据结构索引可以有多种实现方式，也会对性能造成巨大的差异，因此要在不同场景下要选用适合的索引结构。

### 1、线性表

- 数组、链表、栈、队列：没有明确的层级关系，数据之间是相互独立且平等的，数据组织结构是线性的

### 2、树（索引的灵魂）

树：每个节点存储数据，节点间存在父子关系

二叉树：每个节点的**度<=2**

- #### 二叉查找树：

  ​	节点间具有明确的大小关系，一般来说 **左子树 < 父节点 < 右子树**，由于**局部有序**这个特性，所以二叉查找树的查找性能很不错，正常来说都是**二分查找**，时间复杂度为**O(logn)**，因此后续树结构都延续了这一基本思想；但二叉查找树的问题在于，**随着节点增多，其整个树结构可能会变得不太友好，进而影响查询性能**，例如在极端情况下，二叉查找树就会退化为一维数组。（对于确定不变的数据来说，直接构造出的二叉查找树就是非常棒的索引结构，但是对于更多的实际场景中，数据是会变的、会增长的，二叉查找树的结构只是切面高效，而无法做到动态高效。）

  ​	到二叉查找树为止，结构都是比较简单的，其构造规则也比较容易理解。二叉查找树的问题在于随着节点增多无法一直保持高效索引，因此需要在节点增删的同时，对二叉查找树的结构也进行调整（后续改进的关键），时刻保持当前数据下的高效索引。

- #### 平衡二叉树（AVL）：

  ​	平衡二叉树：以二叉查找树为基础，在二叉查找树**插入或删除节点后**，按照特点规则进行**自旋**，以调整树结构，控制每个节点的左右子树的**高度差**。

  - 每个节点的左子树和右子树的高度差不得超过1
  - 平衡二叉树中的每个子树都是平衡二叉树

- 

- 

## 五、联合索引和最左前缀法则

### 1、联合索引的特点

在使用一个索引来实现表中多个字段的索引效果。（若是每个字段都单独设置一个索引，则一张表会建立多棵索引树，存在空间浪费等弊端）

### 2、联合索引是如何存储的

正常的辅助索引树中，是以键值对（当前辅助索引的字段值作为键，相应记录的id（主键）作为值，形如 **Bob：3**）为一个独立单元的，而联合索引将键值对中的键，扩充为多个字段的拼接，形如 **Bob-15-man：3**，其他存储细节与普通的辅助索引树相同。

### 3、最左前缀法则

最左前缀法表示则在拥有联合索引的表中，某条使用到索引的sql语句在实际执行时，是否通过联合索引进行检索（即是否命中联合索引，或是进行了全表扫描（遍历））

```sql
# 表概况
select a,b,c from table1; (10, 20, 30)  (10, 40, 50)  (15, 20, 30)
# 创建联合索引
create index idx_a_b_c on table1(a, b, c);
# 以下sql哪些命中联合索引，哪些没有
select * from table1 where a = 10; 命中联合索引中的a
select * from table1 where a = 10 and b = 20; 命中联合索引中的a,b
select * from table1 where a = 10 and b = 20 and c = 30; 命中联合索引中的a, b, c
select * from table1 where b = 20; 没有命中联合索引，因为缺少联合索引中的最左字段值（即a字段值），需要全表扫描
select * from table1 where b = 20 and c = 30; 同上
select * from table1 where a = 10 and c = 30; 命中联合索引中的a，但没有命中c，因此在所有a = 10的记录中，再遍历扫描获取c = 30的记录（半命中）
select * from table1 where c = 30; 没有命中联合索引，因为缺少联合索引中的最左字段值（即a字段值），需要全表扫描
select * from table1 where a = 10 and c = 30 and b = 20; 命中联合索引中的a, b, c（虽然此语句没有按照abc编写，但是mysql会通过内部优化器进行重排，实际执行的是优化后的语句）
```

总结：若要使用联合索引，则一定要加入最左索引字段





